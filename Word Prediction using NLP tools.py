# -*- coding: utf-8 -*-
"""2018245_mohammad_talib_nlp_assign2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p_PJoo3nB_oeJUKX23Os7aobwnOYpYA8
"""

import nltk
nltk.download('stopwords')
nltk.download('punkt')

import re
import os
import pathlib
import json
import string
import pandas as pd
import numpy as np
from nltk.tokenize import word_tokenize
from nltk.tokenize import RegexpTokenizer
from nltk.stem import WordNetLemmatizer
from nltk.stem import PorterStemmer
from nltk.corpus import stopwords

path = "/content/drive/MyDrive/nlp_data_ass_2/train (2).txt"
data = pd.read_table(path)
data

line = 2206499
dt = data.loc[:line-1]      # data frame short
# dt = ['a b b a a w a b w b','w a a a b a w w']
print(dt)
print(len(dt))

def lower(input_str):
  return input_str.lower()

def remove_punc(input_str):
  result = input_str.translate(str.maketrans("","", string.punctuation))
  return result

def make_token(sentence):
  words = nltk.word_tokenize(sentence)
  new_words= [word for word in words]
  return (new_words)

def make_bigram(text):
  Tokens = nltk.word_tokenize(text)
  output = list(nltk.bigrams(Tokens))
  return (output)

def make_unigram(text):
  words = nltk.word_tokenize(sentence)
  new_words= [word for word in words]
  return (new_words)

def CountFrequency(stri):
    freq = {}
    for item in stri:
        if (item in freq):
            freq[item] += 1
        else:
            freq[item] = 1
            
def sum_all_freq(di):
  c = 0
  for i in di:
    c += di[i]
  return c

unigram_count = {}
bigram_count={}
for i in range(line):
  sentence  = dt.loc[i][0]
  sentence = "$ "+sentence+" #"
  # sentence  = dt[i]
  sentence = lower(sentence)
  bigra = make_bigram(sentence)
  # print(bigra)
  unigra = make_unigram(sentence)
  # print(unigra)

  for j in unigra:
    if j in unigram_count:
      unigram_count[j]=[unigram_count[j][0]+1,0]
    else:
      unigram_count[j]=[1,0]

  for j in bigra:
    if j in bigram_count:
      bigram_count[j]=[bigram_count[j][0]+1,0]
    else:
      bigram_count[j]=[1,0]
  # print()

"""## **Finding Unigrams**"""

V = len(unigram_count)
print("V =",V)
###################### finding unigram counts & probabilities
u_count = 0
for i in unigram_count:
  u_count += unigram_count[i][0]
for i in unigram_count:
  unigram_count[i][1] = unigram_count[i][0] / u_count

print("Unigrams with [count, probability]:\n")
unigram_count

print(1543/248059)

"""## **Finding Bigrams**"""

# finding bigram probabilities
# Without smoothing
for i in bigram_count:
  bigram_count[i][1] = bigram_count[i][0] / unigram_count[i[0]][0]    # computing probabilities

print("Co-occurence matrix ")
print("Bigrams with [count, probability]:\n")
bigram_count

# Without smoothing search
def ws_prob(a,b):
  for i in bigram_count:
    k = (a,b)
    # print(k)
    if k in bigram_count:
      # print("freq :",bigram_count[k][0])
      return (bigram_count[k][1])
      break
    else:
      # print("case-2")
      return 0
      break

search_bigram = input().split()
ws_prob(search_bigram[0],search_bigram[1])

"""### **Json file - test on Without smoothing**"""

path = "/content/drive/MyDrive/nlp_data_ass_2/validation (2).jsonl"
df = pd.read_json(path, lines = True)
df

counter = 0
for i in range(len(df)):  
  opt = df.loc[i][:]['options']
  sent = df.loc[i][:]['question']
  l = "$ "+sent.lower()+" #"
  l = l.split()
  y=l.index('xxxxx')
  print(l)
  print(opt)
  m_prob = []
  tu = {}
  for j in opt:
    ele = (l[y-1],j.lower())

    # # print(ele)
    # if ele in bigram_count:
    #   m_prob.append(bigram_count[ele][1])
    #   tu[ele] = bigram_count[ele][1]
    #   # print(bigram_count[ele][1])
    # else:
    #   m_prob.append(0)
    #   tu[ele] = 0
    #   # print(0)

    tu[ele] = ws_prob(ele[0],ele[1])


    ans = df.loc[i][:]['answer']
  print(tu)
  # print(max(m_prob))
  Keymax = max(tu, key= lambda x: tu[x])
  print(Keymax[1])
  print("Answer :",ans)
  if Keymax[1] == ans:
    print("TRUE")
    counter += 1
  print()
print("Total :", counter)
acc = counter/len(df) * 100
print("Accuracy (%):", acc)

"""### **Calculating Effieciency - Bonus- Without Smoothing**

"""

counter = 0
for i in range(len(df)):  
  opt = df.loc[i][:]['options']
  sent = df.loc[i][:]['question']
  l = "$ "+sent.lower()+" #"
  l = l.split()
  y=l.index('xxxxx')
  prev = y-1
  nextt = y+1
  print(l)
  print(opt)
  tu = {}
  tu1 = {}
  for j in opt:
    ele = (l[y-1],j.lower())
    ele1 = (j.lower(),l[y+1])
    # print(ele,ele1)
    tu[ele] = ws_prob(ele[0],ele[1])
    tu1[ele1] = ws_prob(ele1[0],ele1[1])

    ans = df.loc[i][:]['answer']
  print(tu)
  print(tu1)
  dic = {}
  arr1 = []
  for u in tu:
    arr1.append(tu[u])
  # print(arr1)
  arr2 = []
  for u in tu1:
    arr2.append(tu1[u])
  # print(arr2)
  mul = []
  for i in range(len(arr1)):
    mul.append(arr1[i]*arr2[i])
  # print(mul)
  hh=-1
  for kk in tu:
    hh += 1
    dic[kk[1]]= mul[hh]
  print(dic)

  Keymax = max(dic, key= lambda x: dic[x])
  print(Keymax)
  print("Answer :",ans)
  if Keymax == ans:
    print("TRUE")
    counter += 1
  print()
print("Total :", counter)
acc = counter/len(df) * 100
print("Accuracy (%):", acc)

"""## **Add-1 Laplace smoothing**"""

# With Add-1 Laplace smoothing
# Co-occurence matrix 
# p = 0
for i in bigram_count:
  bigram_count[i][1] = (bigram_count[i][0] + 1) / (unigram_count[i[0]][0] + V)   # computing probabilities Add-1
  # if i[0] == 'w':
  #   p += bigram_count[i][1]

print("Bigram probability with L-smoothing function [count, probability]:\n")
bigram_count
# p

# Add 1 search
def add1_prob(a,b):
  for i in bigram_count:
    k = (a,b)
    # print(k)
    if k in bigram_count:
      return (bigram_count[k][1])
      break
    else:
      # print("case-2")
      den = unigram_count[search_bigram[0]][0] + V
      num = 0 + 1
      return (num/den)
      break

search_bigram = input().split()
add1_prob(search_bigram[0],search_bigram[1])

"""### **Json file - test on With add-1**"""

counter = 0
for i in range(len(df)):  
  opt = df.loc[i][:]['options']
  sent = df.loc[i][:]['question']
  l = "$ "+sent.lower()+ " #"
  l = l.split()
  y=l.index('xxxxx')
  print(l)
  print(opt)
  m_prob = []
  tu = {}
  for j in opt:
    ele = (l[y-1],j.lower())

    # # print(ele)
    # if ele in bigram_count:
    #   m_prob.append(bigram_count[ele][1])
    #   tu[ele] = bigram_count[ele][1]
    #   # print(bigram_count[ele][1])
    # else:
    #   m_prob.append(0)
    #   tu[ele] = 0
    #   # print(0)
    
    tu[ele] = add1_prob(ele[0],ele[1])


    ans = df.loc[i][:]['answer']
  print(tu)
  # print(max(m_prob))
  Keymax = max(tu, key= lambda x: tu[x])
  print(Keymax[1])
  print("Answer :",ans)
  if Keymax[1] == ans:
    print("TRUE")
    counter += 1
  print()
print("Total :", counter)
acc = counter/len(df) * 100
print("Accuracy (%):", acc)

"""### **Calculating Effieciency - Bonus- With Add-1**

"""

counter = 0
for i in range(len(df)):  
  opt = df.loc[i][:]['options']
  sent = df.loc[i][:]['question']
  l = "$ "+sent.lower()+" #"
  l = l.split()
  y=l.index('xxxxx')
  prev = y-1
  nextt = y+1
  print(l)
  print(opt)
  tu = {}
  tu1 = {}
  for j in opt:
    ele = (l[y-1],j.lower())
    ele1 = (j.lower(),l[y+1])
    # print(ele,ele1)
    tu[ele] = add1_prob(ele[0],ele[1])
    tu1[ele1] = add1_prob(ele1[0],ele1[1])

    ans = df.loc[i][:]['answer']
  print(tu)
  print(tu1)
  dic = {}
  arr1 = []
  for u in tu:
    arr1.append(tu[u])
  # print(arr1)
  arr2 = []
  for u in tu1:
    arr2.append(tu1[u])
  # print(arr2)
  mul = []
  for i in range(len(arr1)):
    mul.append(arr1[i]*arr2[i])
  # print(mul)
  hh=-1
  for kk in tu:
    hh += 1
    dic[kk[1]]= mul[hh]
  print(dic)

  Keymax = max(dic, key= lambda x: dic[x])
  print(Keymax)
  print("Answer :",ans)
  if Keymax == ans:
    print("TRUE")
    counter += 1
  print()
print("Total :", counter)
acc = counter/len(df) * 100
print("Accuracy (%):", acc)

"""## **Add-k smoothing**"""

# With Add-k smoothing
k = 200
# p = 0
for i in bigram_count:
  bigram_count[i][1] = (bigram_count[i][0] + k) / (unigram_count[i[0]][0] + (k*V))   # computing probabilities Add-1
  # if i[0] == 'a':
  #   p += bigram_count[i][1]
print("Bigram probability with L-smoothing function [count, probability]:\n")
bigram_count
# p

# Add K search
def addk_prob(a,b):
  for i in bigram_count:
    q = (a,b)
    # print(k)
    if q in bigram_count:
      return (bigram_count[q][1])
      break
    else:
      # print("case-2")
      den = unigram_count[search_bigram[0]][0] + (k*V)
      num = 0 + k
      return (num/den)
      break

search_bigram = input().split()
# print(search_bigram)
addk_prob(search_bigram[0],search_bigram[1])

"""### **Json file - test on With add-K**

"""

counter = 0
for i in range(len(df)):  
  opt = df.loc[i][:]['options']
  sent = df.loc[i][:]['question']
  l = "$ "+sent.lower()+" #"
  l = l.split()
  y=l.index('xxxxx')
  print(l)
  print(opt)
  m_prob = []
  tu = {}
  for j in opt:
    ele = (l[y-1],j.lower())

    # # print(ele)
    # if ele in bigram_count:
    #   m_prob.append(bigram_count[ele][1])
    #   tu[ele] = bigram_count[ele][1]
    #   # print(bigram_count[ele][1])
    # else:
    #   m_prob.append(0)
    #   tu[ele] = 0
    #   # print(0)
    
    tu[ele] = addk_prob(ele[0],ele[1])


    ans = df.loc[i][:]['answer']
  print(tu)
  # print(max(m_prob))
  Keymax = max(tu, key= lambda x: tu[x])
  print(Keymax[1])
  print("Answer :",ans)
  if Keymax[1] == ans:
    print("TRUE")
    counter += 1
  print()
print("Total :", counter)
acc = counter/len(df) * 100
print("Accuracy (%):", acc)

"""### **Calculating Effieciency - Bonus - With Add-k**




"""

counter = 0
for i in range(len(df)):  
  opt = df.loc[i][:]['options']
  sent = df.loc[i][:]['question']
  l = "$ "+sent.lower()+" #"
  l = l.split()
  y=l.index('xxxxx')
  prev = y-1
  nextt = y+1
  print(l)
  print(opt)
  tu = {}
  tu1 = {}
  for j in opt:
    ele = (l[y-1],j.lower())
    ele1 = (j.lower(),l[y+1])
    # print(ele,ele1)
    tu[ele] = addk_prob(ele[0],ele[1])
    tu1[ele1] = addk_prob(ele1[0],ele1[1])

    ans = df.loc[i][:]['answer']
  print(tu)
  print(tu1)
  dic = {}
  arr1 = []
  for u in tu:
    arr1.append(tu[u])
  # print(arr1)
  arr2 = []
  for u in tu1:
    arr2.append(tu1[u])
  # print(arr2)
  mul = []
  for i in range(len(arr1)):
    mul.append(arr1[i]*arr2[i])
  # print(mul)
  hh=-1
  for kk in tu:
    hh += 1
    dic[kk[1]]= mul[hh]
  print(dic)

  Keymax = max(dic, key= lambda x: dic[x])
  print(Keymax)
  print("Answer :",ans)
  if Keymax == ans:
    print("TRUE")
    counter += 1
  print()
print("Total :", counter)
acc = counter/len(df) * 100
print("Accuracy (%):", acc)